package main

import (
	"crypto/rand"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"html/template"
	"log"
	"net/http"
	"os"
	"strings"
	"time"

	"ordm-main/pkg/auth"
	"ordm-main/pkg/ledger"
	"ordm-main/pkg/wallet"
)

type MiningStats struct {
	TotalBlocks    int64   `json:"total_blocks"`
	TotalRewards   int64   `json:"total_rewards"`
	EnergyCost     float64 `json:"energy_cost"`
	Profitability  float64 `json:"profitability"`
	HashRate       float64 `json:"hash_rate"`
	Uptime         int64   `json:"uptime"`
	StakeAmount    int64   `json:"stake_amount"`
	ValidatorLevel string  `json:"validator_level"`
}

type NodeInfo struct {
	Name          string           `json:"name"`
	Port          int              `json:"port"`
	Status        string           `json:"status"`
	IsRunning     bool             `json:"is_running"`
	IsMining      bool             `json:"is_mining"`
	MiningStats   MiningStats      `json:"mining_stats"`
	Balance       map[string]int64 `json:"balance"`
	Peers         []string         `json:"peers"`
	Difficulty    int              `json:"difficulty"`
	EnergyPrice   float64          `json:"energy_price"`
	WalletName    string           `json:"wallet_name"`
	WalletAddress string           `json:"wallet_address"`
}

type TwoFactorAuth struct {
	CurrentPIN      string    `json:"current_pin"`
	GeneratedAt     time.Time `json:"generated_at"`
	ExpiresAt       time.Time `json:"expires_at"`
	Attempts        int       `json:"attempts"`
	MaxAttempts     int       `json:"max_attempts"`
	LockedUntil     time.Time `json:"locked_until"`
	SessionToken    string    `json:"session_token"`
	IsAuthenticated bool      `json:"is_authenticated"`
}

type BlockchainGUI struct {
	Node          NodeInfo              `json:"node"`
	Logs          []string              `json:"logs"`
	IsRunning     bool                  `json:"is_running"`
	WalletManager *wallet.WalletManager `json:"-"`
	GlobalLedger  *ledger.GlobalLedger  `json:"-"`
	TwoFactorAuth *TwoFactorAuth        `json:"-"`
	UserManager   *auth.UserManager     `json:"-"`
}

var gui BlockchainGUI
var miningTicker *time.Ticker
var miningStop chan bool

func NewTwoFactorAuth() *TwoFactorAuth {
	return &TwoFactorAuth{
		MaxAttempts: 3,
		Attempts:    0,
	}
}

func (tfa *TwoFactorAuth) GeneratePIN() string {
	bytes := make([]byte, 3)
	rand.Read(bytes)

	num := int(bytes[0])<<16 | int(bytes[1])<<8 | int(bytes[2])
	pin := fmt.Sprintf("%06d", num%1000000)

	tfa.CurrentPIN = pin
	tfa.GeneratedAt = time.Now()
	tfa.ExpiresAt = time.Now().Add(10 * time.Second) // 10 segundos
	tfa.Attempts = 0
	tfa.IsAuthenticated = false
	tfa.SessionToken = hex.EncodeToString(bytes)

	return pin
}

func (tfa *TwoFactorAuth) ValidatePIN(pin string) (bool, string) {
	if time.Now().Before(tfa.LockedUntil) {
		return false, "Sistema bloqueado. Tente novamente em alguns minutos."
	}

	if time.Now().After(tfa.ExpiresAt) {
		return false, "PIN expirado. Gere um novo PIN."
	}

	if pin == tfa.CurrentPIN {
		tfa.IsAuthenticated = true
		tfa.Attempts = 0
		return true, "Login realizado com sucesso!"
	}

	tfa.Attempts++
	if tfa.Attempts >= tfa.MaxAttempts {
		tfa.LockedUntil = time.Now().Add(15 * time.Minute)
		return false, "Muitas tentativas. Sistema bloqueado por 15 minutos."
	}

	return false, fmt.Sprintf("PIN incorreto. Tentativas restantes: %d", tfa.MaxAttempts-tfa.Attempts)
}

func (tfa *TwoFactorAuth) IsUserAuthenticated() bool {
	return tfa.IsAuthenticated
}

func (tfa *TwoFactorAuth) Logout() {
	tfa.IsAuthenticated = false
	tfa.SessionToken = ""
}

func main() {
	// Inicializar gerenciador de usu√°rios
	userManager := auth.NewUserManager("./data")

	// Inicializar wallet manager
	walletManager := wallet.NewWalletManager("./wallets")

	// Inicializar ledger global
	globalLedger := ledger.NewGlobalLedger("./data", walletManager)

	// Carregar ledger existente
	err := globalLedger.LoadLedger()
	if err != nil {
		fmt.Printf("Aviso: Erro ao carregar ledger: %v\n", err)
	}

	// Inicializar sistema 2FA
	twoFactorAuth := NewTwoFactorAuth()
	pin := twoFactorAuth.GeneratePIN()
	fmt.Printf("üîê PIN 2FA gerado: %s (v√°lido por 10 segundos)\n", pin)

	// Carregar estado de minera√ß√£o se existir
	miningState := loadMiningState()

	// Configurar node minerador individual
	gui = BlockchainGUI{
		Node: NodeInfo{
			Name:          "MinerNode",
			Port:          8080,
			Status:        "Parado",
			IsRunning:     false,
			IsMining:      false,
			MiningStats:   miningState,
			Balance:       make(map[string]int64),
			Peers:         []string{"8081", "8082", "8083"},
			Difficulty:    1,
			EnergyPrice:   0.12,
			WalletName:    "miner_wallet",
			WalletAddress: "",
		},
		Logs:          []string{},
		IsRunning:     false,
		WalletManager: walletManager,
		GlobalLedger:  globalLedger,
		TwoFactorAuth: twoFactorAuth,
		UserManager:   userManager,
	}

	// Carregar wallets existentes do usu√°rio
	loadExistingWallets()

	// Configurar rotas HTTP
	http.HandleFunc("/", handleHome)
	http.HandleFunc("/user-login", handleUserLogin)
	http.HandleFunc("/user-logout", handleUserLogout)
	http.HandleFunc("/login", handleLogin)
	http.HandleFunc("/logout", handleLogout)
	http.HandleFunc("/generate-pin", handleGeneratePIN)
	http.HandleFunc("/start", handleStart)
	http.HandleFunc("/stop", handleStop)
	http.HandleFunc("/start-mining", handleStartMining)
	http.HandleFunc("/stop-mining", handleStopMining)
	http.HandleFunc("/stake", handleStake)
	http.HandleFunc("/transfer", handleTransfer)
	http.HandleFunc("/create-wallet", handleCreateWallet)
	http.HandleFunc("/wallets", handleWallets)
	http.HandleFunc("/status", handleStatus)
	http.HandleFunc("/ledger", handleLedger)

	// Iniciar atualiza√ß√µes em tempo real
	go startRealTimeUpdates()

	// Iniciar servidor HTTP
	fmt.Println("üîó Blockchain 2-Layer - Node Minerador")
	fmt.Println("üì± Interface dispon√≠vel em: http://localhost:3000")
	log.Fatal(http.ListenAndServe(":3000", nil))
}
